/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

///<reference path="objToThree.ts" />
class voxJSCanvas {
    constructor(containerID) {
        // Create the renderer, in this case using WebGL, we want an alpha channel
        let container = document.getElementById(containerID);
        this.renderer = new THREE.WebGLRenderer({ alpha: true });
        // Set dimensions to containers and background color to white
        let containerWidth = 800;
        let containerHeight = 400;
        this.renderer.setSize(containerWidth, containerHeight);
        this.renderer.setClearColor(0xFFFFFF, 1);
        // Bind the renderer to the HTML, parenting it to our 'container' DIV
        container.appendChild(this.renderer.domElement);
        // Create a Scene
        this.scene = new THREE.Scene();
        // And a camera.  Set Field of View, Near and Far clipping planes
        this.camera = new THREE.PerspectiveCamera(45, containerWidth / containerHeight, 0.1, 1000);
        // Position is -20 along the Z axis and look at the origin
        this.camera.position.set(0, 0, -20);
        this.camera.lookAt(new THREE.Vector3(0, 0, 0));
        // Add the lights
        let ambientLight = new THREE.AmbientLight(0x111111);
        this.scene.add(ambientLight);
        let light = new THREE.PointLight(0xFFFFDD);
        light.position.set(-15, 10, 15);
        this.scene.add(light);
    }
    CameraPosition(x, y, z) {
        this.camera.position.set(x, y, z);
    }
    setDimensions(width, height) {
        this.renderer.setSize(width, height);
    }
    setMesh(inputMesh) {
        this.voxel = inputMesh;
        // this.voxel = inputMesh;
        /* var textureMaterial = new THREE.MeshPhongMaterial(
             {
                 map: THREE.ImageUtils.loadTexture("example-models/chr_gumi.png")
             }
         );*/
        // this.voxel.material = textureMaterial;
        // And put it at the origin
        this.voxel.position.set(0, 0, 0);
        // Add it to the scene and render the scene using the Scene and Camera objects
        this.scene.add(this.voxel);
    }
    render() {
        // Each frame we want to render the scene again
        // Use typescript Arrow notation to retain the thisocity passing render to requestAnimationFrame
        // It's possible I invented the word thisocity.
        requestAnimationFrame(() => this.render());
        this.voxel.rotation.y += 0.01;
        this.renderer.render(this.scene, this.camera);
    }
    start() {
        this.render();
    }
}
window.onload = () => {
    let converterOne_canvas = new voxJSCanvas("voxelDemo");
    // var loader = new THREE.OBJLoader();
    //loader.load( 'example-models/chr_gumi.obj', three.setMesh );
    let converterOne_model;
    let objToThree_converter = new objToThree();
    //hard coded a obj file for testing
    let objTest = 'example-models/chr_gumi.obj';
    converterOne_model = objToThree_converter.convert(objTest);
    // converterOne_model = new THREE.Mesh( geometry, material );
    // var geometry = new THREE.BoxGeometry( 5, 5, 5 );
    //	var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
    converterOne_canvas.setMesh(converterOne_model);
    converterOne_canvas.CameraPosition(0, 0, -20);
    converterOne_canvas.start();
};


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgODA0M2EwMjE2OWM4ZDQ5OGE4MzgiLCJ3ZWJwYWNrOi8vLy4vbWFpbi5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxjQUFjO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsa0JBQWtCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6InZveGMubWluLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgODA0M2EwMjE2OWM4ZDQ5OGE4MzgiLCIvLy88cmVmZXJlbmNlIHBhdGg9XCJvYmpUb1RocmVlLnRzXCIgLz5cbmNsYXNzIHZveEpTQ2FudmFzIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXJJRCkge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIHJlbmRlcmVyLCBpbiB0aGlzIGNhc2UgdXNpbmcgV2ViR0wsIHdlIHdhbnQgYW4gYWxwaGEgY2hhbm5lbFxuICAgICAgICBsZXQgY29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY29udGFpbmVySUQpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFRIUkVFLldlYkdMUmVuZGVyZXIoeyBhbHBoYTogdHJ1ZSB9KTtcbiAgICAgICAgLy8gU2V0IGRpbWVuc2lvbnMgdG8gY29udGFpbmVycyBhbmQgYmFja2dyb3VuZCBjb2xvciB0byB3aGl0ZVxuICAgICAgICBsZXQgY29udGFpbmVyV2lkdGggPSA4MDA7XG4gICAgICAgIGxldCBjb250YWluZXJIZWlnaHQgPSA0MDA7XG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U2l6ZShjb250YWluZXJXaWR0aCwgY29udGFpbmVySGVpZ2h0KTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRDbGVhckNvbG9yKDB4RkZGRkZGLCAxKTtcbiAgICAgICAgLy8gQmluZCB0aGUgcmVuZGVyZXIgdG8gdGhlIEhUTUwsIHBhcmVudGluZyBpdCB0byBvdXIgJ2NvbnRhaW5lcicgRElWXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLnJlbmRlcmVyLmRvbUVsZW1lbnQpO1xuICAgICAgICAvLyBDcmVhdGUgYSBTY2VuZVxuICAgICAgICB0aGlzLnNjZW5lID0gbmV3IFRIUkVFLlNjZW5lKCk7XG4gICAgICAgIC8vIEFuZCBhIGNhbWVyYS4gIFNldCBGaWVsZCBvZiBWaWV3LCBOZWFyIGFuZCBGYXIgY2xpcHBpbmcgcGxhbmVzXG4gICAgICAgIHRoaXMuY2FtZXJhID0gbmV3IFRIUkVFLlBlcnNwZWN0aXZlQ2FtZXJhKDQ1LCBjb250YWluZXJXaWR0aCAvIGNvbnRhaW5lckhlaWdodCwgMC4xLCAxMDAwKTtcbiAgICAgICAgLy8gUG9zaXRpb24gaXMgLTIwIGFsb25nIHRoZSBaIGF4aXMgYW5kIGxvb2sgYXQgdGhlIG9yaWdpblxuICAgICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5zZXQoMCwgMCwgLTIwKTtcbiAgICAgICAgdGhpcy5jYW1lcmEubG9va0F0KG5ldyBUSFJFRS5WZWN0b3IzKDAsIDAsIDApKTtcbiAgICAgICAgLy8gQWRkIHRoZSBsaWdodHNcbiAgICAgICAgbGV0IGFtYmllbnRMaWdodCA9IG5ldyBUSFJFRS5BbWJpZW50TGlnaHQoMHgxMTExMTEpO1xuICAgICAgICB0aGlzLnNjZW5lLmFkZChhbWJpZW50TGlnaHQpO1xuICAgICAgICBsZXQgbGlnaHQgPSBuZXcgVEhSRUUuUG9pbnRMaWdodCgweEZGRkZERCk7XG4gICAgICAgIGxpZ2h0LnBvc2l0aW9uLnNldCgtMTUsIDEwLCAxNSk7XG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKGxpZ2h0KTtcbiAgICB9XG4gICAgQ2FtZXJhUG9zaXRpb24oeCwgeSwgeikge1xuICAgICAgICB0aGlzLmNhbWVyYS5wb3NpdGlvbi5zZXQoeCwgeSwgeik7XG4gICAgfVxuICAgIHNldERpbWVuc2lvbnMod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIHNldE1lc2goaW5wdXRNZXNoKSB7XG4gICAgICAgIHRoaXMudm94ZWwgPSBpbnB1dE1lc2g7XG4gICAgICAgIC8vIHRoaXMudm94ZWwgPSBpbnB1dE1lc2g7XG4gICAgICAgIC8qIHZhciB0ZXh0dXJlTWF0ZXJpYWwgPSBuZXcgVEhSRUUuTWVzaFBob25nTWF0ZXJpYWwoXG4gICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICBtYXA6IFRIUkVFLkltYWdlVXRpbHMubG9hZFRleHR1cmUoXCJleGFtcGxlLW1vZGVscy9jaHJfZ3VtaS5wbmdcIilcbiAgICAgICAgICAgICB9XG4gICAgICAgICApOyovXG4gICAgICAgIC8vIHRoaXMudm94ZWwubWF0ZXJpYWwgPSB0ZXh0dXJlTWF0ZXJpYWw7XG4gICAgICAgIC8vIEFuZCBwdXQgaXQgYXQgdGhlIG9yaWdpblxuICAgICAgICB0aGlzLnZveGVsLnBvc2l0aW9uLnNldCgwLCAwLCAwKTtcbiAgICAgICAgLy8gQWRkIGl0IHRvIHRoZSBzY2VuZSBhbmQgcmVuZGVyIHRoZSBzY2VuZSB1c2luZyB0aGUgU2NlbmUgYW5kIENhbWVyYSBvYmplY3RzXG4gICAgICAgIHRoaXMuc2NlbmUuYWRkKHRoaXMudm94ZWwpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIC8vIEVhY2ggZnJhbWUgd2Ugd2FudCB0byByZW5kZXIgdGhlIHNjZW5lIGFnYWluXG4gICAgICAgIC8vIFVzZSB0eXBlc2NyaXB0IEFycm93IG5vdGF0aW9uIHRvIHJldGFpbiB0aGUgdGhpc29jaXR5IHBhc3NpbmcgcmVuZGVyIHRvIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuICAgICAgICAvLyBJdCdzIHBvc3NpYmxlIEkgaW52ZW50ZWQgdGhlIHdvcmQgdGhpc29jaXR5LlxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5yZW5kZXIoKSk7XG4gICAgICAgIHRoaXMudm94ZWwucm90YXRpb24ueSArPSAwLjAxO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlcih0aGlzLnNjZW5lLCB0aGlzLmNhbWVyYSk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH1cbn1cbndpbmRvdy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgbGV0IGNvbnZlcnRlck9uZV9jYW52YXMgPSBuZXcgdm94SlNDYW52YXMoXCJ2b3hlbERlbW9cIik7XG4gICAgLy8gdmFyIGxvYWRlciA9IG5ldyBUSFJFRS5PQkpMb2FkZXIoKTtcbiAgICAvL2xvYWRlci5sb2FkKCAnZXhhbXBsZS1tb2RlbHMvY2hyX2d1bWkub2JqJywgdGhyZWUuc2V0TWVzaCApO1xuICAgIGxldCBjb252ZXJ0ZXJPbmVfbW9kZWw7XG4gICAgbGV0IG9ialRvVGhyZWVfY29udmVydGVyID0gbmV3IG9ialRvVGhyZWUoKTtcbiAgICAvL2hhcmQgY29kZWQgYSBvYmogZmlsZSBmb3IgdGVzdGluZ1xuICAgIGxldCBvYmpUZXN0ID0gJ2V4YW1wbGUtbW9kZWxzL2Nocl9ndW1pLm9iaic7XG4gICAgY29udmVydGVyT25lX21vZGVsID0gb2JqVG9UaHJlZV9jb252ZXJ0ZXIuY29udmVydChvYmpUZXN0KTtcbiAgICAvLyBjb252ZXJ0ZXJPbmVfbW9kZWwgPSBuZXcgVEhSRUUuTWVzaCggZ2VvbWV0cnksIG1hdGVyaWFsICk7XG4gICAgLy8gdmFyIGdlb21ldHJ5ID0gbmV3IFRIUkVFLkJveEdlb21ldHJ5KCA1LCA1LCA1ICk7XG4gICAgLy9cdHZhciBtYXRlcmlhbCA9IG5ldyBUSFJFRS5NZXNoQmFzaWNNYXRlcmlhbCggeyBjb2xvcjogMHgwMGZmMDAgfSApO1xuICAgIGNvbnZlcnRlck9uZV9jYW52YXMuc2V0TWVzaChjb252ZXJ0ZXJPbmVfbW9kZWwpO1xuICAgIGNvbnZlcnRlck9uZV9jYW52YXMuQ2FtZXJhUG9zaXRpb24oMCwgMCwgLTIwKTtcbiAgICBjb252ZXJ0ZXJPbmVfY2FudmFzLnN0YXJ0KCk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9tYWluLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=